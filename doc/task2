Напишите worker pool на основе каналов.

Одна горутина создает “задачи”, набор горутин выполняет эти “задачи”.

В качестве задачи выполните расчет md5 для переданной строки.

Worker pool — это такой шаблон проектирования, который позволяет ограничить количество одновременно работающих горутин. Это помогает контролировать степень параллелизма выполнения этих задач. Представьте, что каждая задача выполняет сетевой запрос в сторонний сервис. Создав worker pool на N горутин мы таким образом получим возможность контролировать нагрузку. Более N запросов одновременно не будет выполняться. Например, это позволит сглаживать всплески в кол-ве приходящих задач и не перегружать запросами внешнюю систему. Не путайте c rate limiter, там другие принципы расчета, хоть задачи и кажутся похожими.

Worker pool работает следующим образом:

Создание задач: Есть определённое количество задач, которые нужно выполнить. Например, каждая задача должна выполнить некоторый расчет и отправить дальше результат этого расчета в очередь.
Создание worker pool: Pool состоит из фиксированного количества горутин. Каждый worker будет брать задачи из очереди задач и выполнять их.
Очередь задач: Для задач создаётся канал, через который рабочие горутины будут получать задачи.
Запуск workers: Каждый worker запускается в отдельной горутине и начинает ожидать задачи из очереди.
Обработка задач: Worker берет задачи из очереди и обрабатывают их. После завершения задачи worker читает из канала следующую задачу.
Завершение работы: Когда все задачи выполнены и все workers завершили работу, worker pool закрывается. Этот шаг опциональный, т.к. worker pool может существовать все время жизни приложения.
package homework

import (
	"crypto/md5"
	"encoding/hex"
	"sync"
)

// Worker represents a worker that can process tasks.
type Worker struct {
	// Channel to receive tasks.
	tasks <-chan string
	// WaitGroup to signal when the worker is done.
	wg *sync.WaitGroup
	// Channel to write results
	out chan string
}

// NewWorker creates a new worker.
func NewWorker(tasks <-chan string, wg *sync.WaitGroup, out chan string) *Worker {
	return &Worker{
		tasks: tasks,
		wg:    wg,
		out:   out,
	}
}

// Run starts the worker.
func (w *Worker) Run() {
	// Ваш код
}
 

Для понимания того, что тестируется внутри, прикладываем реализацию теста

package homework

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"sync"
	"testing"

	"github.com/stretchr/testify/require"
)

func hashHex(s string) string {
	hash := md5.Sum([]byte(s))
	return hex.EncodeToString(hash[:])
}

func TestWorkerPool(t *testing.T) {
	tasks := make(chan string)
	out := make(chan string, 100)

	var wg sync.WaitGroup
	var workers []*Worker

	for i := 0; i < 4; i++ {
		wg.Add(1)
		worker := NewWorker(tasks, &wg, out)
		go worker.Run()
		workers = append(workers, worker)
	}

	results := make(map[string]string)

	for i := 0; i < 100; i++ {
		key := fmt.Sprintf("task-%d", i)
		tasks <- key
		results[hashHex(key)] = key
	}

	close(tasks)

	wg.Wait()
	close(out)

	for _, w := range workers {
		for val := range w.out {
			if _, ok := results[val]; ok {
				delete(results, val)
				continue
			}
			t.Error(fmt.Sprintf("hash %s was not expected (task-0...task-99)", val))
		}
	}

	require.Equal(t, 0, len(results), fmt.Sprintf("Found orphan unchecked records: %s", results))
}